#include <cassert>
#include <chrono>
#include <ff/pipeline.hpp>
#include <iostream>
#include <vector>

#include "../include/types.hpp"
#include "ff_node_acc_t.hpp"

using namespace std::chrono;

// ------------------------- Emitter -------------------------------
// This emitter generates two vectors of integers and sends them to the next
// node. It also prepares a task that contains the data to be processed. The
// task is sent only once, and it contains the size of the vectors.
class Emitter : public ff::ff_node {
 public:
   explicit Emitter(size_t n) : n_(n), sent_(false) {
      a_.resize(n_);
      b_.resize(n_);
      c_.resize(n_);
      for (size_t i = 0; i < n_; ++i) {
         a_[i] = static_cast<int>(i);
         b_[i] = static_cast<int>(2 * i);
      }
      task_.a = a_.data();
      task_.b = b_.data();
      task_.c = c_.data();
      task_.n = n_;
   }

   void *svc(void *) override {
      std::cerr << "[emitter] sent=" << (sent_ ? "EOS\n" : "TASK\n");
      if (sent_)
         return EOS;
      sent_ = true;
      return &task_;
   }

   // --- GETTER ripristinati ------------------------------------
   const std::vector<int> &getA() const { return a_; }
   const std::vector<int> &getB() const { return b_; }
   std::vector<int> &getC() { return c_; }

 private:
   size_t n_;
   bool sent_;
   std::vector<int> a_, b_, c_;
   Task task_{};
};

// ------------------------- Collector -----------------------------
// This collector receives the results from the previous node and checks if they
// are correct. It compares the results with the expected values (a + b) and
// prints a message indicating whether the CPU baseline is correct or not. It
// also deletes the result object to free memory. The collector is the last node
// in the pipeline, and it receives the EOS signal when the pipeline is finished
// processing all tasks. It uses the vectors generated by the emitter to verify
// the results. The collector does not produce any output, it only checks the
// results. It is designed to work with the ff_node_acc_t node, which performs
// the vector addition in parallel using FastFlow's parallelism features.
class Collector : public ff::ff_node {
 public:
   Collector(const std::vector<int> &a, const std::vector<int> &b,
             std::vector<int> &c)
       : a_(a), b_(b), c_(c) {}

   void *svc(void *r) override {
      if (!r)
         return EOS;
      auto *res = static_cast<Result *>(r);

      bool ok = true;
      for (size_t i = 0; i < res->n; i += res->n / 16 + 1)
         if (c_[i] != a_[i] + b_[i]) {
            ok = false;
            break;
         }

      std::cout << (ok ? "CPU baseline OK!" : "Baseline FAILED!") << '\n';
      delete res;
      return EOS;
   }

 private:
   const std::vector<int> &a_;
   const std::vector<int> &b_;
   std::vector<int> &c_;
};

// --------------------------- main --------------------------------
// This is the main function that initializes the FastFlow pipeline.
// It creates an Emitter node that generates two vectors of integers,
// an ff_node_acc_t node that performs the vector addition in parallel,
// and a Collector node that checks the results.
int main(int argc, char *argv[]) {
   const size_t N = (argc > 1) ? std::stoull(argv[1]) : 1'000'000;

   Emitter emitter(N);
   ff_node_acc_t accNode;
   Collector collector(emitter.getA(), emitter.getB(), emitter.getC());

   ff::ff_Pipe<> pipe(emitter, accNode, collector);

   using clock = std::chrono::steady_clock;
   const auto t0 = clock::now(); // ─── start misurazione globale

   if (pipe.run_and_wait_end() < 0) { 
      std::cerr << "run error\n";
      return -1;
   }

   const auto t1 = clock::now(); // ─── end misurazione globale
   using us = std::chrono::microseconds;
   const auto elapsed_us = std::chrono::duration_cast<us>(t1 - t0).count();

   std::cout << "N=" << N << " elements, elapsed=" << elapsed_us << " µs\n";
   return 0;
}
